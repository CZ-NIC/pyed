#!/usr/bin/env python3
#
import argparse
import logging
import re
import sys
# noinspection PyUnresolvedReferences
from collections import defaultdict
from collections.abc import Iterable, Callable
# noinspection PyUnresolvedReferences
from datetime import *
from itertools import islice
# noinspection PyUnresolvedReferences
from math import *
from re import *

# logging
logging.basicConfig(level=logging.INFO, format='%(message)s', stream=sys.stderr)
logger = logging.getLogger(__name__)

# names that can be imported
available_names = {"Path": "pathlib",
                   "sleep": "time",
                   "randint": "random",
                   "get": "requests"}
available_modules = ["pathlib", "time", "jsonpickle", "humanize", "requests"]

__doc__ = f"Launch your tiny Python script on a piped in contents and pipe it out" \
          "\n" \
          "\nAvailable without import:" \
          f"\n Loaded: re.* (match, search, findall), math.* (sqrt,...), datetime.* (datetime.now, ...)," \
          f" defaultdict" \
          f"\n Auto-imported functions: {', '.join(available_names.keys())}," \
          f"\n Auto-imported modules: {', '.join(available_modules)}"

# parse arguments
parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument("command", help='Any Python script (multiple statements allowed)', metavar="COMMAND")
parser.add_argument("-s", "--setup", help='Any Python script, executed before processing.'
                                          ' Useful for variable initializing.', metavar="COMMAND")
parser.add_argument("--finally", help='Any Python script, executed after processing.'
                                      ' Useful for final output.', metavar="COMMAND")
parser.add_argument("-v", "--verbose", help='Show command exceptions.'
                                            ' Used twice to show automatic imports.', action='count', default=0)
parser.add_argument("-f", "--filter", help='Line is piped out unchanged, however only if evaluated to True.',
                    action='store_true')
parser.add_argument("-n", help='Process only such number of lines.', type=int, metavar="NUM")
parser.add_argument("-1", help='Process just first line. Useful in combination with --whole.'
                               ' You may want to add -1 flag.', action='store_true')
parser.add_argument("-w", "--whole", help='Wait till whole text and then process.'
                                          ' Variable `text` is available containing whole text.', action='store_true')
parser.add_argument("--empty", help='Output empty lines. (By default skipped.)', action='store_true')
parser.add_argument("-0", help='Skip all lines output. (Useful in combination with --finally.)', action='store_true')

regular = parser.add_argument_group("Regular output")
regular.add_argument("--search", help='Equivalent to `search(COMMAND, line)`', action='store_true')
regular.add_argument("--match", help='Equivalent to `match(COMMAND, line)`', action='store_true')
regular.add_argument("--findall", help='Equivalent to `findall(COMMAND, line)`', action='store_true')
regular.add_argument("--sub", help='Equivalent to `sub(COMMAND, SUBSTITUTION, line)`', metavar="SUBSTITUTION")

args = parser.parse_args()
if getattr(args, "1"):
    args.n = 1

logger.setLevel({0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}[args.verbose])

# variables available in the user scope
i = 0
set_ = Set = set()
list_ = List = list()
dict_ = Dict = dict()
skip = None  # if user sets to False, the line will not be output
skip_all = getattr(args, "0")  # XXX add a test
whole_hint_printed = False

# enrich commands (prepend `line =` if needed)
command = {}
regular_command = None  # prepare regular modifications
reg_ex = None
if args.match or args.findall or args.search or args.sub:
    reg_ex = re.compile(args.command)
    if args.match:
        regular_command = reg_ex.match
    elif args.search:
        regular_command = reg_ex.search
    elif args.findall:
        regular_command = reg_ex.findall
    elif args.sub:
        regular_command = lambda line: reg_ex.sub(args.sub, line)


def modify_command(name):
    command[name] = cmd = (getattr(args, name) or "").strip()

    if name == "command" and regular_command:
        # prepending `line = ` is not needed, the string is treated as a `match` parameter
        return

    if (len(cmd.splitlines()) == 1
            and not search("(s|skip)\s?[^=]?=[^=]", cmd)
            and ";" not in cmd
            and "lines." not in cmd):
        # there is only a single line and without assignment
        # "s = 1" - will not pass
        # "s += 1" - will not pass
        # "s + 1" - will pass
        # "s == 1" - will pass
        # "lines.append" - will not pass XX deprecated
        command[name] = ("skip = not " if args.filter else "s = ") + cmd
        logger.debug(f"Changing the {name} command to {command[name]}")


[modify_command(name) for name in ("command", "finally")]

# prepare text processing (either fetch whole or line by line)
if args.whole:
    # fetch whole text
    text = sys.stdin.read()  # XX we may stop reading text and use what we have on KeyboardInterrupt
    loop = (line for line in text.splitlines()[:args.n])
else:
    # load lines one by one (while taking at most N lines)
    loop = islice(sys.stdin, args.n)

# run setup
if args.setup:
    exec(args.setup)


def output(line):
    # output one or more lines
    if isinstance(line, Match):
        # replace with the tuple of the groups or whole matched string (if no group matched)
        line = line.groups() or line.group(0)
    if line:  # empty string makes no output
        if isinstance(line, str):
            print(line)
        elif isinstance(line, list):  # list is output as multiple lines
            [output(el) for el in line]
        elif isinstance(line, Iterable):  # tuple or generator (but not a string) gets joined
            print(", ".join(str(el) for el in line))
        elif isinstance(line, Callable):  # tuple or generator (but not a string) gets joined
            print(line())
        else:  # ex: int, str
            print(line)
    else:
        if args.empty:
            print(line)


while True:
    try:
        s = next(loop).rstrip()
        try:
            n = int(s)
        except:
            n = None
            pass
    except (KeyboardInterrupt, StopIteration):
        break

    try:
        while True:
            # loop until all on the fly imports are done
            skip = None
            try:
                # note that exec will not affect local field, hence we cannot easily put this in a method
                if regular_command:
                    try:
                        s = regular_command(s)
                    except re.error as e:
                        logger.error(f"{e}, regular expression: {command['command']} on line: {s}")
                        break
                else:
                    exec(command["command"])
            except NameError as e:
                name = re.match(r"name '(.*?)' is not defined", str(e))[1]
                if name:
                    # Import anything on the fly (saved performance when loaded)
                    if name == "text":
                        if not whole_hint_printed:
                            logger.error("Did not you forget to use --whole?")
                            whole_hint_printed = True
                        raise
                    elif name in available_names:
                        module = available_names[name]
                        logger.info(f"Importing {name} from {module}")
                        # ex sleep = getattr(module "time", "sleep")
                        globals()[name] = getattr(__import__(module), name)
                    elif name in available_modules:
                        logger.warning(f"Importing {name}")
                        globals()[name] = __import__(name)
                    else:
                        raise
                    continue
            else:
                if skip or (skip_all and skip is not False):  # user chooses to filter out the line
                    break

                output(s)
                break
    except Exception as e:
        logger.warning(f'Exception: {type(e)} {e} on line: {s}')
        continue

# run final script
if command["finally"]:
    s = None
    exec(command["finally"])
    output(s)
