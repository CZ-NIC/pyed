#!/usr/bin/env python3
#
import argparse
import logging
import re
import sys
# noinspection PyUnresolvedReferences
from collections import defaultdict, Counter
from collections.abc import Iterable, Callable
from contextlib import contextmanager
# noinspection PyUnresolvedReferences
from datetime import *
from itertools import islice, count
# noinspection PyUnresolvedReferences
from math import *
from re import *

# logging
logging.basicConfig(level=logging.INFO, format='%(message)s', stream=sys.stderr)
logger = logging.getLogger(__name__)

# names that can be imported
available_names = {"Path": "pathlib",
                   "sleep": "time",
                   "randint": "random",
                   "get": "requests",
                   "b64encode": "base64",
                   "b64decode": "base64",
                   "glob": "glob",
                   "iglob": "glob",
                   "ZipFile": "zipfile"}
_module_clash = {v for k, v in available_names.items() if k == v}  # do not import glob in favour of glob.glob
available_modules = ({x for x in available_names.values() if x not in _module_clash}
                     .union(("csv", "jsonpickle", "humanize", "webbrowser", "collections", "itertools")))

__doc__ = (f"Launch your tiny Python script on a piped in contents and pipe it out"
           "\n"
           "\nAvailable without import:"
           f"\n Loaded: re.* (match, search, findall), math.* (sqrt,...), datetime.* (datetime.now, ...),"
           f" defaultdict"
           f"\n Auto-imported functions: {', '.join(sorted(available_names.keys(), key=str.casefold))}"
           f"\n Auto-imported modules: {', '.join(sorted(available_modules))}"
           f"\n"
           f"\nAvailable variables:"
           f"\n * s – current line"
           f"\n * n – current line converted to an `int` (or `float`) if possible"
           f"\n * text – whole text, all lines together"
           f"\n * lines – list of lines so far processed"
           f"\n * numbers – list of numbers so far processed"
           f"\n * skip – omit line if True"
           f"\n * i=0, S=set(), L=list(), D=dict(), C=Counter() – other global variables"
           )

# parse arguments
parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawTextHelpFormatter)
parser.add_argument("main", help='Any Python script (multiple statements allowed)',
                    metavar="COMMAND", nargs="?")
parser.add_argument("-S", "--setup", help='Any Python script, executed before processing.'
                                          ' Useful for variable initializing.', metavar="COMMAND")
parser.add_argument("-E", "--end", help='Any Python script, executed after processing.'
                                        ' Useful for final output.', metavar="COMMAND")
parser.add_argument("-v", "--verbose", help='Show automatic imports and internal command modification',
                    action="store_true")
parser.add_argument("-q", "--quiet", help='Suppress command exceptions', action='store_true')
parser.add_argument("-F", "--filter", help='Line is piped out unchanged, however only if evaluated to True.',
                    action='store_true')
parser.add_argument("-n", help='Process only such number of lines.', type=int, metavar="NUM")
parser.add_argument("-1", help='Process just first line. Useful in combination with --text.'
                               ' You may want to add -1 flag.', action='store_true')
parser.add_argument("-t", "--text", help='Wait till whole text and then process.'
                                         ' Variable `text` is available containing whole text.', action='store_true')
parser.add_argument("--empty", help='Output empty lines. (By default skipped.)', action='store_true')
parser.add_argument("-0", help='Skip all lines output. (Useful in combination with --end.)', action='store_true')
parser.add_argument("--lines", help='Populate `lines` and `numbers` with lines. This is off by default'
                                    ' due to an overflow when handling an infinite input.', action='store_true')
parser.add_argument("-g", "--generate", help='Generate lines while ignoring the input pipe.'
                                             ' Line will correspond to the iteration cycle count.'
                                             ' If `NUM` not specified, 5 lines will be produced by default.'
                                             ' Putting `NUM == 0` means an infinite generator.',
                    nargs="?", type=int, metavar="NUM", const=5)
parser.add_argument("-f", "--format", help='Main and end clauses are considered f-strings.', action='store_true')

regular = parser.add_argument_group("Regular output")
regular.add_argument("--search", help='Equivalent to `search(COMMAND, s)`', action='store_true')
regular.add_argument("--match", help='Equivalent to `match(COMMAND, s)`', action='store_true')
regular.add_argument("--findall", help='Equivalent to `findall(COMMAND, s)`', action='store_true')
regular.add_argument("--sub", help='Equivalent to `sub(COMMAND, SUBSTITUTION, s)`', metavar="SUBSTITUTION")

# evaluate command line arguments
args = parser.parse_args()
logger.setLevel(logging.ERROR if args.quiet else (logging.DEBUG if args.verbose else logging.WARNING))
if getattr(args, "1"):
    args.n = 1

# determine args.run and possibly turn on args.lines and args.text
args.run = True  # True = run whole processing, 1 = partial run, False = do not run
if not args.main:
    if args.end is None:
        logger.error("You have to specify either main COMMAND or --end COMMAND.")
        quit()

    # no main clause specified -> we may limit or turn off processing
    setattr(args, "0", True)  # suppress output
    args.text = True  # fetch the input at once
    args.run = False  # running can be skipped

    if args.lines or any(x for x in ("numbers", "lines") if x in args.end):
        args.run = 1  # partial run
        args.lines = True

if args.end:
    # end clause will implicitly turn on lines
    args.lines = True
    if not args.run:
        args.run = 1


# custom functions
match_class = match('', '').__class__ if sys.version_info < (3, 7) else Match  # drop with Python3.6


def write(v):
    """ Print either bytes or string. Bytes are not printed in the Python b-form: b'string' but raw. """
    if type(v) is bytes:
        sys.stdout.buffer.write(v + b'\n')
    else:
        print(v)


@contextmanager
def auto_import():
    """ If line processing fails with a NameError, check """
    global whole_hint_printed
    try:
        yield
    except NameError as e:
        name = re.match(r"name '(.*?)' is not defined", str(e))[1]
        if name:
            # Import anything on the fly (saved performance when loaded)
            if name == "text":
                if not whole_hint_printed:
                    logger.warning("Did you not forget to use --text to access `text`?")
                    whole_hint_printed = True
                raise
            elif name in ("numbers", "lines"):
                if not whole_hint_printed:
                    logger.warning("Did you not forget to use --lines to access `lines` and `numbers`?")
                    whole_hint_printed = True
                raise
            elif name in available_names:
                module = available_names[name]
                logger.info(f"Importing {name} from {module}")
                # ex sleep = getattr(module "time", "sleep")
                globals()[name] = getattr(__import__(module), name)
            elif name in available_modules:
                logger.info(f"Importing {name}")
                globals()[name] = __import__(name)
            else:
                raise


def try_argument(callable_, argument, var, cmd="main"):
    """ Try to pass an argument to a callable. Returns False if TypeError happened. """
    t = f"attempt to use `{var}` as the callable parameter in the {cmd} clause: {command[cmd]}({argument})"
    try:
        output(callable_(argument))
        command[cmd] += f"({var})"
    except TypeError as e:
        logger.debug(f"Failed {t} with: {e}")
        return False
    else:
        logger.debug(f"Successful {t}")
        return True


def output(line, final_round=None):
    """ output one or more lines """
    global tried_to_correct_callable
    if isinstance(line, match_class):
        # replace with the tuple of the groups or whole matched string (if no group matched)
        line = line.groups() or line.group(0)
    if line:  # empty string makes no output
        if isinstance(line, (str, bytes)):
            write(line)
        elif isinstance(line, list):  # list is output as multiple lines
            [output(el) for el in line]
        elif isinstance(line, Iterable):  # tuple or generator (but not a string) gets joined
            write(", ".join(str(el) for el in line))
        elif isinstance(line, Callable):  # tuple or generator (but not a string) gets joined
            try:
                output(line())
            except TypeError:
                if tried_to_correct_callable and not final_round:
                    # this it not the first line of the main command nor the `--end` clause,
                    # we have already been there without success
                    raise
                tried_to_correct_callable = True
                # ex: `| pz webbrowser.open` -> `| pz webbrowser.open(s)`
                # ex: `sqrt() takes exactly one argument (0 given)`
                # ex: `open() missing required argument 'file' (pos 1)'` (build-in open)
                # ex: `open() missing 1 required positional argument: 'url'` (webbrowser.open)
                # Unfortunately, there is no certain way to determine the wanted type.
                # The wording of TypeError exceptions specifying the type vary.
                # The best we have is to use the inspect module to get the annotation or the parameter name.
                # We content to try it multiple things to pass as an argument.
                attempts = []
                if not final_round:
                    attempts.append((original_line, "s"))
                    if args.lines:
                        attempts.append((numbers, "numbers"))
                    else:
                        logger.debug("Since `--lines` flag is off, we will not try `numbers`.")
                    if n is not None:
                        # ex: echo  5 | pz sqrt | pz round
                        attempts.append((n, "n"))
                    import inspect
                    try:
                        param = list(inspect.signature(line).parameters.values())[0]
                        if param.name != "iterable":
                            # ex: pz b64encode += (s.encode('utf-8'))
                            logger.debug("Let's try `s.encode('utf-8')` automatically too.")
                            attempts.append((original_line.encode("utf-8"), "s.encode('utf-8')"))
                    except ValueError:  # ex: `set.add` raises no signature found
                        pass
                else:  # we are in the `--end` clause, original_line is empty, we use `lines` or `numbers` instead
                    if len(numbers) == len(lines):
                        # ex: echo -e "1\n2\n3\n4" | pz --end sum
                        attempts.append((numbers, "numbers", "end"))
                    # ex: echo -e "1\n2\n3\n4" | pz  --end "' - '.join" ->  1 - 2 - 3 - 4
                    attempts.append((lines, "lines", "end"))
                if not any(try_argument(line, *x) for x in attempts):
                    raise
        else:  # ex: int, str
            write(line)
    else:
        if args.empty or (line == 0 and line is not False):
            write(line)


def get_number(v):
    num = None
    try:
        # we prefer having int over float because adding values '5' + '5' as '10'
        # looks better than '10.0' in most use cases
        num = float(v)
        num = int(v)  # "10.0" -> int conversion fails and num stays float
    except (ValueError, TypeError):
        pass
    return num


def prepare_command(name):
    c = (getattr(args, name) or "").strip()

    if args.format:
        c = "f'''" + c + "'''"

    if name == "main" and regular_command:
        # prepending `line = ` is not needed, the string is treated as a `match` parameter
        pass
    elif (len(c.splitlines()) == 1  # check if there is only a single line with a missing assignment
            and not search(r"(s|skip)\s?[^=]?=[^=]", c)  # ex: `s = s+= 1` would fail
            # do not assign to reserved keywords (ex: `s = if s == 1: ...` would fail)
            and not any(c.lstrip().startswith(keyword) for keyword in ("if", "while", "for"))
            and ";" not in c
            and "lines." not in c):
        # "s = 1" - will not pass
        # "s += 1" - will not pass
        # "s + 1" - will pass
        # "s == 1" - will pass
        # "if s == 1: print(s)" - will not pass
        c = ("skip = not " if args.filter else "s = ") + c
        logger.debug(f"Changing the {name} clause to: {c}")
    command[name] = c


# empty variables available in the user scope
i = 0
S = set()
L = list()
D = dict()
C = Counter()
skip = None  # if user sets to False, the line will not be output
skip_all = getattr(args, "0")
whole_hint_printed = False

# prepare commands (prepend `line =` if needed)
command = {}
regular_command = None  # prepare regular modifications
reg_ex = None
if args.match or args.findall or args.search or args.sub:
    reg_ex = re.compile(args.main)
    if args.match:
        regular_command = reg_ex.match
    elif args.search:
        regular_command = reg_ex.search
    elif args.findall:
        regular_command = reg_ex.findall
    elif args.sub:
        regular_command = lambda line: reg_ex.sub(args.sub, line)
[prepare_command(name) for name in ("main", "end")]

# prepare text processing (either fetch whole or line by line)
# Note: do not initialize the `text` to None. We want to be able to catch
# `<class 'NameError'> name 'text' is not defined` while not turning `--text` on
text: str
if args.generate is not None:
    # `--generate=5` → 1,2,3,4,5
    # `--generate=0` -> 1 .. infinity
    # When used an infinite generator, it overflows at the end. However, I think the more common use is to profit
    # from the line number generated than be afraid of the overflow
    # that can be avoided by: `pz "while True: print(1)" -g1`
    loop = (str(i) for i in (range(1, args.generate + 1) if args.generate else count(1)))
elif args.text:
    # fetch whole text
    text = sys.stdin.read().rstrip()  # we strip the last newline
    # XX we may stop reading text and use what we have on KeyboardInterrupt
    loop = (line for line in text.splitlines()[:args.n])
else:
    # load lines one by one (while taking at most N lines)
    loop = islice(sys.stdin, args.n)

# run the setup clause
if args.setup:
    while True:
        with auto_import():
            exec(args.setup)
            break


# filled-in variables available in the user scope
n = None
lines: list
numbers: list

if args.lines:
    lines = []
    numbers = []

# internal processing variables
tried_to_correct_callable = False
original_line = s = None

# run processing
if args.run:  # speed up when there is no main clause
    while True:
        try:
            original_line = s = next(loop).rstrip()
            n = get_number(s)
            if args.lines:
                # it might be undefined by purpose (and user should not see it)
                # noinspection PyUnboundLocalVariable
                lines.append(s)
                if n:
                    # noinspection PyUnboundLocalVariable
                    numbers.append(n)
        except (KeyboardInterrupt, StopIteration):
            break

        if args.run is not True:  # speed up, further processing not needed
            continue

        try:
            while True:
                with auto_import():
                    # loop until all on the fly imports are done
                    skip = None
                    # we process either a regular expression or a custom command
                    if regular_command:
                        try:
                            s = regular_command(s)
                        except re.error as e:
                            logger.error(f"{e}, regular expression: {command['main']} on line: {s}")
                            break
                    else:  # resolving custom command
                        # note that exec will not affect local field, hence we cannot easily put this in a method
                        exec(command["main"])
                    if skip or (skip_all and skip is not False):  # user chooses to filter out the line
                        break
                    output(s)
                    break
        except BrokenPipeError:
            # do not continue processing when pipe is broken
            # ex: KeyboardInterrupt cast to a processes that pz infinite generator pipes into
            raise
        except KeyboardInterrupt:  # useful for ending up an infinite generator
            break
        except Exception as e:
            logger.warning(f'Exception: {type(e)} {e} on line: {s}')
            continue

# run final script
if command["end"]:
    if not args.text and args.lines:
        # --text was off by default so we did not wait whole input to be piped in before processing.
        # The variable `text` was not available before but there is no obstacle in letting it
        # to be automatically available at the end – we have everything needed in the `lines` variable.
        text = "\n".join(lines)

    original_line = s = n = None
    try:
        while True:
            with auto_import():
                exec(command["end"])
                output(s, True)
                break
    except Exception as e:
        logger.warning(f'Exception: {type(e)} {e} in the --end clause')
